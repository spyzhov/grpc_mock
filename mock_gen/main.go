package main

import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	pretty "golang.org/x/tools/imports"
)

const (
	generatedSuffix = ".pb.go"
	mockedSuffix    = ".mock.go"
)

type (
	PackageName string
	ServiceName string
	Method      struct {
		Name string
		In   string
		Out  string
	}
)

var (
	reServiceName = regexp.MustCompile(`ServiceName: "([^"]+)",`)
)

func main() {
	var (
		input  string
		output string
	)
	flag.StringVar(&input, "input", input, "folder with *.pb.go files")
	flag.StringVar(&output, "output", output, "folder where *.mock.go files will be generated")
	flag.Parse()
	// todo: add validations
	if input == "" || output == "" {
		log.Fatal("Input and Output paths should be set")
	}
	WriteMock(output)
	err := filepath.Walk(input, func(path string, info os.FileInfo, err error) error {
		if info.IsDir() {
			return nil
		}
		if strings.HasSuffix(path, generatedSuffix) {
			Process(path, output)
		}
		return nil
	})
	if err != nil {
		panic(err)
	}
}

func Process(filename string, outputPath string) {
	printf("proccess: %s", filename)
	baseName := filepath.Base(filename)
	outputName := strings.TrimSuffix(baseName, generatedSuffix) + mockedSuffix
	input := Must(ioutil.ReadFile(filename)).([]byte)

	imports := map[string]string{
		"context":                              "context",
		"github.com/spyzhov/grpc_mock/manager": "manager",
		"github.com/spyzhov/grpc_mock/protob":  ".",
	}
	buf := new(bytes.Buffer)
	services := GetServiceNames(input)
	for pkg, names := range services {
		printf("found package: %s", pkg)
		for _, service := range names {
			printf("found service: %s.%s", pkg, service)
			serviceName := fmt.Sprintf("Mocked%sServer", service)
			Must(fmt.Fprintf(buf, `
type %s struct {
	Unimplemented%sServer
}
`, serviceName, service))
			for _, method := range GetServiceMethods(input, service) {
				printf("found method: %s.%s/%s", pkg, service, method.Name)
				Must(fmt.Fprintf(buf, `
func (s *%s) %s(_ context.Context, in *%s) (*%s, error) {
	ret, err := manager.Call("%s", "%s", "%s", in, new(%s))
	out, _ := ret.(*%s)
	return out, err
}
`,
					serviceName, method.Name, method.In, method.Out,
					pkg, service, method.Name, method.Out,
					method.Out))
				for _, t := range []string{method.In, method.Out} {
					if alias, path := GetImport(input, t); alias != "" {
						imports[path] = alias
					}
				}
			}
			AppendMock(outputPath, service)
		}
	}

	result := new(bytes.Buffer)
	Must(fmt.Fprintf(result, `// Code generated by mock_gen. DO NOT EDIT.
// source: %s

package mock

import (`, baseName))
	for path, alias := range imports {
		Must(fmt.Fprintf(result, "\t%s \"%s\"\n", alias, path))
	}
	Must(fmt.Fprintf(result, ")\n\n"))
	Must(result.Write(Must(ioutil.ReadAll(buf)).([]byte)))

	data := Must(ioutil.ReadAll(result)).([]byte)
	data = Must(pretty.Process(outputName, data, &pretty.Options{
		Fragment:   false,
		AllErrors:  true,
		Comments:   true,
		TabIndent:  true,
		TabWidth:   8,
		FormatOnly: true,
	})).([]byte)

	//fmt.Printf("%s%s%s\n%s", strings.Repeat("=", 20), baseName, strings.Repeat("=", 20), string(input))
	//fmt.Printf("%s%s%s\n%s", strings.Repeat("=", 20), outputName, strings.Repeat("=", 20), string(data))

	Check(ioutil.WriteFile(filepath.Join(outputPath, outputName), data, 0666))
}

func Check(err error) {
	if err != nil {
		panic(err)
	}
}

func Must(in interface{}, err error) interface{} {
	Check(err)
	return in
}

func WriteMock(outputPath string) {
	filename := filepath.Join(outputPath, "mock.go")
	Check(ioutil.WriteFile(filename, []byte(`// Code generated by mock_gen. DO NOT EDIT.

package mock

import (
	"github.com/spyzhov/grpc_mock/protob"
	"google.golang.org/grpc"
)

func Mock(srv *grpc.Server) {
}
`), 0666))
}

func AppendMock(outputPath string, service ServiceName) {
	filename := filepath.Join(outputPath, "mock.go")
	str := fmt.Sprintf("\tprotob.Register%sServer(srv, new(Mocked%sServer))\n}\n", service, service)
	data := Must(ioutil.ReadFile(filename)).([]byte)
	data = data[:len(data)-2]
	data = append(data, []byte(str)...)
	Check(ioutil.WriteFile(filename, data, 0666))
}

func printf(format string, v ...interface{}) {
	log.Printf(format, v...)
}

// region Parser

func GetServiceNames(input []byte) map[PackageName][]ServiceName {
	result := make(map[PackageName][]ServiceName, 1)
	for _, match := range reServiceName.FindAllSubmatch(input, -1) {
		parts := strings.Split(string(match[1]), ".")
		name := ServiceName(parts[len(parts)-1])
		pkg := PackageName(strings.Join(parts[:len(parts)-1], "."))
		if _, ok := result[pkg]; !ok {
			result[pkg] = make([]ServiceName, 0, 1)
		}
		result[pkg] = append(result[pkg], name)
	}
	return result
}

func GetServiceMethods(input []byte, service ServiceName) []Method {
	re := regexp.MustCompile(`func \(\*Unimplemented` + string(service) + `Server\) ([^\(]+)\(.*context.Context, [^\*]*\*([^\)]+)\) \(\*([^,]+), error\) {`)
	result := make([]Method, 0)
	for _, match := range re.FindAllSubmatch(input, -1) {
		result = append(result, Method{
			Name: string(match[1]),
			In:   string(match[2]),
			Out:  string(match[3]),
		})
	}
	return result
}

func GetImport(input []byte, typeName string) (string, string) {
	index := strings.Index(typeName, ".")
	if index == -1 {
		return "", ""
	}
	alias := typeName[:index]
	re := regexp.MustCompile(`\n\t` + alias + ` "([^"]+)"\n`)
	for _, match := range re.FindAllSubmatch(input, -1) {
		return alias, string(match[1])
	}
	return "", ""
}

// endregion Parser
